# 语法

## Hello World

qas 的执行流程使用 yaml 描述，完全遵循 [yaml](https://yaml.org/spec/1.2.2/) 的描述语法

一个最简单的可执行的完整测试如下：

```yaml
name: hello-world

ctx:
  shell:
    type: shell

case:
  - name: HelloWorld
    step:
      - ctx: shell
        req:
          command: echo -n hello world
        res:
          exitCode: 0
          stdout: hello world
```

主要包含 `ctx` 和 `case` 两个部分，ctx 中描述了访问后端服务的驱动，case 中描述了具体测试单元执行的步骤和断言

## 语法结构

- `name`: 测试名称，可以不填，默认为父目录名字
- `var`: 变量，通过变量给后面引用
- `ctx`: 执行上下文，主要是一些全局的驱动（一般是服务的 client），每一个步骤都需要在一个驱动中执行
    - `type`: 驱动的名称，目前支持 `shell/http/mysql/redis/oss/ots/pop/mns`
    - `args`: 初始化驱动的参数，不同的驱动初始化参数参考 [驱动参数](驱动参数)
    - `dft`: 驱动参数的默认值
        - `req`: 默认请求参数
        - `retry`: 默认重试参数
            - `attempts`: 默认重试次数
            - `delay`: 默认重试间隔
        - `until`: 默认等待参数，执行步骤直到某个条件满足
            - `attempts`: 默认重试次数
            - `delay`: 默认重试间隔
- `case`: 具体测试单元
    - `name`: case 名称，必填参数
    - `cond`: 条件执行
    - `preStep`: 前置步骤，字符串数组，步骤名来着于 `commonStep`
    - `postStep`: 后置步骤，字符串数组，步骤名来自于 `commonStep`
    - `step`: 执行步骤
        - `ctx`: 上下文名称，值来自于上面的 key
        - `req`: 传给驱动的请求
        - `res`: 期望驱动的返回
        - `cond`: 条件执行
        - `retry`: 重试参数
            - `cond`: 重试条件，默认为空，即不重试
            - `attempts`: 重试次数，默认为 1
            - `delay`: 重试间隔，默认 1s
        - `until`: 等待参数，执行步骤直到某个条件满足
            - `cond`: 等待条件，默认为空，即不等待
            - `attempts`: 等待次数，默认 5
            - `delay`: 等待间隔，默认 1s
- `setUp`: 一个特殊的 `case`，在所有 `case` 执行之前执行
- `tearDown`: 一个特殊的 `case`，在所有 `case` 执行之后执行
- `beforeCase`: 一组特殊的 `step`，在每个 `case` 执行前执行
- `afterCase`: 一组特殊的 `step`，在每个 `case` 执行后执行
- `commonStep`: 一些公共的 `step`，可以由 `case.preStep` 和 `case.postStep` 引用

### ctx 测试对象

`ctx` 是一些可执行的测试对象，`case` 中的每个 `step` 都需要在一个 `ctx` 中执行，`ctx` 一般是一些 client，比如 http client/mysql client 等等，
也可以是一些特殊功能的容器，比如 shell 可以执行 shell 命令，或者运行 python/ruby 等脚本

`ctx` 是一个字典格式，key 是 `ctx` 的名字，这个名字用于在后面的 `step` 中引用，value 描述了 driver 的类型 `type` 以及对应的启动参数 `args` 和默认参数 `dft`，
目前支持的 `type` 的值有 `shell/http/mysql/redis/oss/ots/pop/mns`，不同的 `type` 对应不同的 `args` 初始化参数，详情参考[驱动参数](/docs/用户指南/驱动参数)

### case 测试单元

`case` 是一个测试的基本单元，主要包括测试所需要的执行步骤，执行流程先执行 `preStep -> step -> postStep`，其中任何一个步骤失败，
会导致整个 `case` 执行失败而退出；`case` 通过 `cond` 支持条件执行

### step 测试步骤

`step` 描述了一个执行步骤，将 `req` 中的参数传给 `ctx` 获取执行的结果，然后和 `res` 中结果进行断言，任何一个断言失败都会导致整个步骤断言失败；
`step` 可以在 `retry` 和 `until` 中定义[重试和等待策略](#retryuntil)；`step` 通过 `cond` 支持条件执行

## 断言

一个 case（执行单元）是由若干个 step（执行步骤）组成，执行步骤的 res 是执行的结果，测试其实就是对执行结果的校验

`qas` 使用和返回结果相同的结构来描述期望的结果，支持直接 value 断言和 python 表达式断言

1. 直接 value 断言，直接判断返回的 value 和期望的 value 是否相等
2. python 表达式断言，以 `#` 开头的 key 会执行这种断言
    - 断言结果是一个 bool 值，当结果为 true 时，断言通过
    - 断言结果非 `bool` 值，当结果和断言值相等时，断言通过

在 python 表达式断言中，可以直接引用 `case`，`step`，`var`，`val` 的值，参考[变量引用](#变量引用)

```yaml
name: assert-example

ctx:
  shell:
    type: shell

case:
  - name: AssertExample
    step:
      - ctx: shell
        req:
          command: |
            echo '{
              "key1": "val1",
              "key2": 123,
              "key3": {
                "key4": "val4",
                "key5": [{
                  "key6": "val6",
                  "key7": [
                    456,
                    "val7"
                  ],
                  "key8": 333
                }]
              }
            }'
          decoder: json
        res:
          exitCode: 0
          json: {
            "key1": "val1",
            "#key2": "val % 3 == 0",
            "key3": {
              "#key4": "len(val) == 4",
              "key5": [{
                "#key6": "val.endswith('6')",
                "key7": [
                  456,
                  "val7"
                ],
                "#key8": "111 * 3"
              }]
            }
          }
```

## 变量引用

qas 支持如下几种变量引用

- `var`: 引用在 `var` 中定义的常量，这些常量是全局的，可以在任何 `case` 和 `ctx` 中引用
- `case`: 引用当前的 `case`，通过 `case` 可以引用其他步骤的结果或者请求，比如 `case.steps[1].res['status']` 引用当前 `case` 的第 2 步中的返回结果的 `status` 字段
- `step`: 引用当前的 `step`，如：`step.req['cmd']`，引用当前步骤请求中的 `cmd` 字段，也可通过 `step` 引用返回结果中的其他字段，如: `step.res['key1']`
- `val`: 引用返回结果当前节点的值，仅在断言中可引用

```yaml
name: var-example

var:
  key1: val1
  key2:
    key3: val3
    key4:
      - key5: val5
        key6: val6

ctx:
  shell:
    type: shell

case:
  - name: VarExample
    step:
      - ctx: shell
        req:
          command: |
            echo "${KEY1}"
            echo "${KEY2_KEY3}"
            echo "${KEY2_KEY4_0_KEY5}"
            echo "${KEY2_KEY4_0_KEY6}"
          envs:
            "#KEY1": var.key1
            "#KEY2_KEY3": var.key2.key3
            "#KEY2_KEY4_0_KEY5": var.key2.key4[0].key5
            "#KEY2_KEY4_0_KEY6": var.key2.key4[0].key6
        res:
          exitCode: 0
          stdout: |
            val1
            val3
            val5
            val6
  - name: CaseExample
    step:
      - ctx: shell
        req:
          command: date +%s
        res:
          "#stdout": "(datetime.now() - datetime.fromtimestamp(int(val))).total_seconds() < 3"
      - ctx: shell
        req:
          command: |
            echo -n "${KEY7}"
          envs:
            "#KEY7": "case.steps[0].res['stdout']"
        res:
          "#stdout": "step.req['envs']['KEY7']"
```

## dft 默认值

`step` 中的 `req` 有可能有很多相同的参数，这些参数在每个步骤里面都写一遍会显得很冗长，也不利于维护，`qas` 提供了 `ctx.dft.req` 来解决类似的问题，
在执行 `step` 前，会将 `step.req` 和 `ctx.dft.req` 合并，`step.req` 中的字段会覆盖 `ctx.dft.req`，`ctx.dft.req` 中的字段会补充到 `step.req`，

同样的，`step.retry` 和 `step.until` 策略，也可以通过 `ctx.dft.retry` 和 `ctx.dft.until` 来定义默认值

```yaml
name: dft-example

var:
  key1: val1

ctx:
  shell:
    type: shell
    dft:
      req:
        envs:
          "#KEY1": var.key1

case:
  - name: VarExample
    step:
      - ctx: shell
        req:
          command: echo "${KEY1}"
        res:
          exitCode: 0
          stdout: |
            val1
```

## retry/until

`retry` 重试策略，一般用来解决偶尔不太符合预期的返回，比如网络环境较差条件下的超时，通过 `attempts` 设置重试次数，
`delay` 设置每次重试的间隔，`cond` 表示重试的条件，如果条件为空，不会重试

```yaml
name: retry-example

ctx:
  shell:
    type: shell

case:
  - name: RetryExample
    step:
      - ctx: shell
        retry:
          cond: "int(step.res['stdout']) % 5 != 0"
          attempts: 10
          delay: 1s
        req:
          command: date +%s
        res:
          exitCode: 0
          "#stdout": "int(val) % 5 == 0"
```

`until` 等待策略，一般用于预期内的条件等待，比如等待任务达到完成状态，参数和 `retry` 是一致的

事实上 `until` 就是 `retry` 的反向条件，二者从逻辑上可以相互转换，之所以会有两种实现，是想从场景下区分，
`retry` 侧重不符合预期的重试，而 `until` 侧重符合预期的等待

```yaml
name: until-example

ctx:
  shell:
    type: shell

case:
  - name: RetryExample
    step:
      - ctx: shell
        until:
          cond: "int(step.res['stdout']) % 5 == 0"
          attempts: 10
          delay: 1s
        req:
          command: date +%s
        res:
          exitCode: 0
          "#stdout": "int(val) % 5 == 0"
```

## 条件执行

`case` 和 `step` 都通过 `cond` 字段来支持条件执行，`cond` 字段中也可以引用 `var/case/step` 变量，只是需要注意时序的问题，`cond`
条件的判断发生在 `case` 和 `step` 之前，因此无法引用未执行的结果，但可以引用已执行的结果

条件执行一种典型的应用场景是，一个服务在不同的环境下有多种实现（比如数据库在共有云使用 ots，在专有云使用 rds），
不同的实现可以对应不同的 `step` 校验，而这种在不同环境下执行不同的 `step`，就依赖于条件执行的特性

此外条件执行跳过的步骤，不影响 `step` 在 `case` 中引用的序号，被跳过的 `step` 会被标记为 skip 后依然插入到 steps 中

```yaml
name: cond-example

var:
  key1: val1

ctx:
  shell:
    type: shell

case:
  - name: CondPassExample
    cond: "var.key1 == 'val1'"
    step:
      - ctx: shell
        req:
          command: date +%s
        res:
          exitCode: 0
      - ctx: shell
        cond: "int(case.steps[0].res['stdout']) % 2 == 1"
        req:
          command: echo odd
      - ctx: shell
        cond: "int(case.steps[0].res['stdout']) % 2 == 0"
        req:
          command: echo even
  - name: CondDenyExample
    cond: "var.key1 == 'val2'"
    step:
      - ctx: shell
        req:
          command: |
            echo "this case whill skip by cond"
```

## setUp/tearDown

`setUp/tearDown` 是特殊的两组 `case`，`setUp` 在程序开始执行，典型场景是用来初始化测试的环境，比如构造测试数据，上传测试文件之类的，
`tearDown` 在程序结束时执行，典型场景是用来清理测试环境，删除构造数据，保持测试环境的干净，方便重复测试

```yaml
name: setup-teardown-example

ctx:
  shell:
    type: shell

setUp:
  - name: SetUpCase
    step:
      - ctx: shell
        req:
          command: echo setup

tearDown:
  - name: TearDownCase
    step:
      - ctx: shell
        req:
          command: echo teardown

case:
  - name: SetUpTearDownExample
    step:
      - ctx: shell
        req:
          command: echo case
```

## beforeCase/afterCase

`beforeCase/afterCase` 是两组公共的 `step`，`beforeCase` 会在每个 `case` 执行之前执行，`afterCase` 会在每个 `case` 之后执行，
这些 `step` 的结果同样可以通过 `case.before_case_steps` 和 `case.after_case_steps` 引用

```yaml
name: before-after-case-example

ctx:
  shell:
    type: shell

beforeCase:
  - ctx: shell
    req:
      command: echo before case

afterCase:
  - ctx: shell
    req:
      command: echo after case

case:
  - name: BeforeAfterCaseExample
    step:
      - ctx: shell
        req:
          command: echo case
```

## preStep/postStep

`beforeCase/afterCase` 机制会在每个 `case` 中都执行，有时候我们希望一些步骤只在特定的 `case` 中执行，并且可以灵活地控制 `step` 执行的顺序，
`preStep/postStep` 机制就是用来解决这个问题的，通过再 `commonStep` 中定义公共步骤，在 `case.preStep` 和 `case.postStep` 中可以引用这些步骤，
这些步骤会分别在 `case.step` 执行之前和之后执行

```yaml
name: pre-post-step-example

ctx:
  shell:
    type: shell

commonStep:
  step1:
    ctx: shell
    req:
      command: echo step1
  step2:
    ctx: shell
    req:
      command: echo step2

case:
  - name: PrePostStepExample
    preStep:
      - step1
    postStep:
      - step2
    step:
      - ctx: shell
        req:
          command: echo case step
```

## 链接

- yaml 语法: <https://yaml.org/spec/1.2.2/>
