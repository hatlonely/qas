# 语法

## hello world

qas 的执行流程使用 yaml 描述，完全遵循 [yaml](https://yaml.org/spec/1.2.2/) 的描述语法

一个最简单的可执行的完整测试如下：

```yaml
name: hello-world

ctx:
  shell:
    type: shell

case:
  - name: HelloWorld
    step:
      - ctx: shell
        req:
          command: echo -n hello world
        res:
          exitCode: 0
          stdout: hello world
```

主要包含 `ctx` 和 `case` 两个部分，ctx 中描述了访问后端服务的驱动，case 中描述了具体测试单元执行的步骤和断言

## 语法结构

- `name`: 测试名称，可以不填，默认为父目录名字
- `var`: 变量，通过变量给后面引用
- `ctx`: 执行上下文，主要是一些全局的驱动（一般是服务的 client），每一个步骤都需要在一个驱动中执行
    - `type`: 驱动的名称，目前支持 `shell/http/mysql/redis/oss/ots/pop/mns`
    - `args`: 初始化驱动的参数，不同的驱动初始化参数参考 [驱动参数](驱动参数)
    - `dft`: 驱动参数的默认值
        - `req`: 默认请求参数
        - `retry`: 默认重试参数
            - `attempts`: 默认重试次数
            - `delay`: 默认重试间隔
        - `until`: 默认等待参数，执行步骤直到某个条件满足
            - `attempts`: 默认重试次数
            - `delay`: 默认重试间隔
- `case`: 具体测试单元
    - `name`: case 名称，必填参数
    - `cond`: 条件执行
    - `preStep`: 前置步骤，字符串数组，步骤名来着于 commonStep
    - `postStep`: 后置步骤，字符串数组，步骤名来自于 commonStep
    - `step`: 执行步骤
        - `ctx`: 上下文名称，值来自于上面的 key
        - `req`: 传给驱动的请求
        - `res`: 期望驱动的返回
        - `cond`: 条件执行
        - `retry`: 重试参数
            - `cond`: 重试条件，默认为空，即不重试
            - `attempts`: 重试次数，默认为 1
            - `delay`: 重试间隔，默认 1s
        - `until`: 等待参数，执行步骤直到某个条件满足
            - `cond`: 等待条件，默认为空，即不等待
            - `attempts`: 等待次数，默认 5
            - `delay`: 等待间隔，默认 1s
- `setUp`: 一个特殊的 case，在所有 case 执行之前执行
- `tearDown`: 一个特殊的 case，在所有 case 执行之后执行
- `beforeCase`: 一组特殊的 step，在每个 case 执行前执行
- `afterCase`: 一组特殊的 step，在每个 case 执行后执行
- `commonStep`: 一些公共的 step，可以由 case.preStep 和 case.postStep 引用

## 断言

一个 case（执行单元）是由若干个 step（执行步骤）组成，执行步骤的 res 是执行的结果，测试其实就是对执行结果的校验

`qas` 使用和返回结果相同的结构来描述期望的结果，支持直接 value 断言和 python 表达式断言

1. 直接 value 断言，直接判断返回的 value 和期望的 value 是否相等
2. python 表达式断言，以 `#` 开头的 key 会执行这种断言
    - 断言结果是一个 bool 值，当结果为 true 时，断言通过
    - 断言结果非 `bool` 值，当结果和断言值相等时，断言通过

在 python 表达式断言中，可以直接引用 `case`，`step`，`var`，`val` 的值，参考[变量引用](#变量引用)

```yaml
name: assert-example

ctx:
  shell:
    type: shell

case:
  - name: AssertExample
    step:
      - ctx: shell
        req:
          command: |
            echo '{
              "key1": "val1",
              "key2": 123,
              "key3": {
                "key4": "val4",
                "key5": [{
                  "key6": "val6",
                  "key7": [
                    456,
                    "val7"
                  ],
                  "key8": 333
                }]
              }
            }'
          decoder: json
        res:
          exitCode: 0
          json: {
            "key1": "val1",
            "#key2": "val % 3 == 0",
            "key3": {
              "#key4": "len(val) == 4",
              "key5": [{
                "#key6": "val.endswith('6')",
                "key7": [
                  456,
                  "val7"
                ],
                "#key8": "111 * 3"
              }]
            }
          }
```

## 变量引用

qas 支持

- `var`: 引用[全局变量](#var 全局变量)
- `case`: 引用当前的 `case`，通过 `case` 可以引用其他步骤的结果或者请求，比如 `case.steps[1].res['status']` 引用当前 `case` 的第 2 步中的返回结果的 `status` 字段
- `step`: 引用当前步骤，`step.req['cmd']`，引用当前步骤请求中的 `cmd` 字段，也可通过 `step` 引用返回结果中的其他字段，如: `step.res['key1']`
- `val`: 引用返回结果当前节点的值

```yaml
name: var-example

var:
  key1: val1
  key2:
    key3: val3
    key4:
      - key5: val5
        key6: val6

ctx:
  shell:
    type: shell

case:
  - name: VarExample
    step:
      - ctx: shell
        req:
          command: |
            echo "${KEY1}"
            echo "${KEY2_KEY3}"
            echo "${KEY2_KEY4_0_KEY5}"
            echo "${KEY2_KEY4_0_KEY6}"
          envs:
            "#KEY1": var.key1
            "#KEY2_KEY3": var.key2.key3
            "#KEY2_KEY4_0_KEY5": var.key2.key4[0].key5
            "#KEY2_KEY4_0_KEY6": var.key2.key4[0].key6
        res:
          exitCode: 0
          stdout: |
            val1
            val3
            val5
            val6
  - name: CaseExample
    step:
      - ctx: shell
        req:
          command: date +%s
        res:
          "#stdout": "(datetime.now() - datetime.fromtimestamp(int(val))).total_seconds() < 3"
      - ctx: shell
        req:
          command: |
            echo -n "${KEY7}"
          envs:
            "#KEY7": "case.steps[0].res['stdout']"
        res:
          "#stdout": "case.steps[0].res['stdout']"

```

## dft 默认值

## retry/until

## 条件执行

## setUp/tearDown

## beforeCase/afterCase

## preStep/postStep


## var 变量引用

有一些字符串会在可能会在各个 case 中反复使用，而且为了让 case 能在不同的环境下运行，这些值可能会修改，qas 提供 var 来定义这些变量，
在后面的 ctx 和 case 中在 key 前面增加 `#` 标识，通过 `var.variable` 引用，比如：

```yaml
var:
  jsontestEndpoint: "http://echo.jsontest.com/"

ctx:
  jsontest:
    type: http
    args:
      "#endpoint": "var.jsontestEndpoint"
```

var 也可以是更复杂的嵌套结构，通过 `var.key1[idx].key2` 来访问，比如

```yaml
var:
  key1:
    - key2: val12
      key3: val13
  key4: val4

case:
  - name: UseVariable
    step:
      - ctx: shell
        req:
          command: "echo $MY_VARIABLE"
          envs:
            "#MY_VARIABLE": "var.key1[0].key2"
```

事实上，以 `#` 开头标识的 key 是会通过 python 的 eval 执行，因此支持完整的 python 语法，因此上面的例子也可以写成

```yaml
var:
  key1:
    - key2: val12
      key3: val13
  key4: val4

case:
  - name: UseVariable
    step:
      - ctx: shell
        req:
          command: "'echo {}'.format(var.key1[0].key2)"
```

## ctx 测试对象

ctx 是一些可执行的测试对象，case 中的每个步骤（step）都需要在一个 ctx 中执行，ctx 一般是一些 client，比如 http client/mysql client 等等，
也可以是一些特殊功能的容器，比如 shell 可以执行 shell 命令，或者运行 python/ruby 等脚本

ctx 是一个字典格式，key 是 ctx 的名字，这个名字用于在后面的执行步骤（step）中引用，value 描述了 driver 的类型以及对应的启动参数和默认参数
目前支持的 type 的值有 `shell/http/mysql/redis/oss/ots/pop/mns`，不同的 type 对应不同的 args 初始化参数，详情参考[驱动参数](/docs/用户指南/驱动参数.md)

retry 和 until 是执行 step 的重试和等待策略默认值

```yaml
ctx:
  py:
    type: shell
    args:
      shebang: python3
      args:
        - -c
  db:
    type: mysql
    args:
      host: localhost
      port: 3306
      username: hatlonely
      password: "123456"
      database: testdb
  rpc:
    type: http
    args:
      endpoint: https://awesome.service.com/
    dft:
      # 默认请求使用 GET 方法，超时时间 10s
      req:
        method: GET
        timeout: 10s
      # 默认在返回值大于 500 时重试，重试 3 次，每次间隔 3 秒
      retry:
        cond: "step.res['status'] >= 500"
        attempts: 3
        delay: 3s
  mns:
    type: mns
    args:
      AccessKeyId: test-ak
      AccessKeySecret: test-sk
      Endpoint: test-endpoint
    dft:
      req:
        Queue: test-queue
      # 默认在等待条件满足前，执行 10 次，每次间隔 1 秒
      until:
        attempts: 10
        delay: 1s
```

## case 测试单元

case 描述了测试的基本单元，

```yaml
case:
  - name: EchoHelloWorld
    desc: |
      1. 调用 api 创建一个任务
      2. 从 mns 中接收消息
    step:
      - ctx: rpc
        req:
          method: POST
          path: /v1/createJob
          json:
            source: oss://test-bucket/test-object
            notifyEndpoint: test-endpoint
            notifyTopic: test-topic
        res:
          status: 201
          json:
            "#id": "len(val) == 32"
            status: "Running"
      - ctx: mns
        req:
          Action: ReceiveMessage
```

## 链接

- yaml 语法: <https://yaml.org/spec/1.2.2/>
